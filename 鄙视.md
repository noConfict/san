## 1、将每个单词首字母转大写

```js
var str="you can you up";
    str=str.replace(
        /\b[a-z]/ig,
        function(a){
            console.log(`
            自动调用了回调函数,
            传入实参值a=${a}返回${a.toUpperCase()}...`)
                    //转为大写字母
            return a.toUpperCase();
        }
    )
```

### 2替换敏感词

```js
  function trimLeft(str){
        return str.replace(/^\s+/,"");
    }
    function trimRight(str){
        return str.replace(/\s+$/,"");
    }
    function trim(str){
        return str.replace(/^\s+|\s+$/g,"");
    }
    var str="  zhang  dong   ";
    console.log(trimLeft(str));
    console.log(trimRight(str));
    console.log(trim(str));
```

### 3翻转字符串

```js
var str="helloword";
  var arr=str.split("");
  arr.reverse();
  str=arr.join("");
  console.log(str);
```

### 4RegExp对象: 

 什么是: 专门保存一条正则表达式，并提供用正则表达式进行验证和查找的函数 的对象

为什么: 因为js语言默认不认识正则表达式，需要一个对象将正则翻译为js认识的东西

 何时: 今后只要在js中使用正则表达式，都要先创建正则表达式对象

 坑: ""中正则中的\x，都要变成\\x, 第一个\用来保护第二个



### 5函数

什么是: 程序中专门保存一段可反复使用的代码段的程序结构，再起一个名字

 为什么: 重用

 何时: 只要一段代码可能被反复使用时，都要先将代码保存在一个函数中，再反复调用函数来重用代码

```js
function fun(a,b,c){
		//函数体;
		return a+b+c;
	}
fun(1,2,3);
```

1. 用声明方式创建：

2. 用赋值方式创建:  

3. 用new来创建: (写法太复杂，几乎不用)

   ### 6重载(overload)

    什么是: 相同函数名，不同形参列表的多个函数，在调用时，可根据传入的实参值不同，动态选择匹配的函数来调用！

   \2. 何时: 只要同一件事，可能根据传入的实参值不同，自动执行不同的逻辑时，都要用重载！

   \3. 优点: 可以减少函数名的个数，可以减轻调用者的负担

   \4. 问题: JS语言不支持多个同名函数同时存在的！

   \5. 解决: js中如何实现重载: 

   ​	(1). 只定义一个函数，且不要定义任何形参！

   ​	(2). (不用自己做)其实每个函数中都有一个自带的可直接使用的arguments： 

   ​	a. 每个函数中都自带的——不用创建可直接使用

   ​	b. 自动接收所有传入函数的实参值的——内容

   ​	c. 类数组对象：长得像数组的对象

   ​	arguments: {    }.length

   ```js
    function pay(){
         if(arguments.length==0){
             console.log(`手机支付...`);
         }else if(arguments.length==1){
             console.log(`现金支付...，收您${arguments[0]}元`);
         }else{
             console.log(`刷卡支付...从您卡号${arguments[0]}扣款成功`);
         }
     }
     pay();
     pay(200);
     pay("6430  3214","1234");
   ```

   ### 7匿名函数: 

   ##### \1. 什么是: 定义函数时不指定函数名的函数

   ##### \2. 为什么: 2个原因: 

   ​	(1). 节约内存——用完就被立刻释放了

   ​	(2). 划分临时作用域，防止全局污染

   ##### \3. 何时: 2个主要场景: 

   ​	(1). 几乎所有回调函数都用匿名函数——节约内存

   ​	(2). 今后所有的js程序都要包裹在一个匿名函数自调中——禁止使用全局变量，防止全局污染

   ### 8 什么是作用域(scope): 2种解释: 

   ​	(1). 用途: 一个变量的可用范围.

   ​	(2). 本质: 也是一个专门保存变量的对象

   #### \2. 为什么: 避免不同范围之间的变量互相干扰！

   \3. js中包括2级作用域: 

   ### 	(1). 全局作用域: 

   ​	a. 什么是: 专门保存全局变量的作用域范围/对象

   ​	b. 特点: 随处可用！可反复使用！

   ​	c. 何时: 今后只要需要反复使用一个变量或希望在任何位置都能使用这个变量时，都将变量创建在全局范围内！

   ​	d. 本质: 其实全局作用域是一个名为window的对象！

   ​		1). 在浏览器一打开时，就自动创建

   ​		2). 我们在全局创建的所有变量和函数都是保存在window对象中！

   ​	e. 优点: 可反复使用！

   ​	f. 缺点: 随处可用——极易被污染！

   ​	g. 结论: 今后在公司中，禁止使用一切全局变量！

   ​	(2). 函数作用域: 

   ​	a. 什么是: 专门保存只能在函数内使用的局部变量的范围/对象

   ​	b. 特点: 仅在函数内可用！不可重用！

   ​	c. 何时: 只要希望一个变量只能在函数内使用，出了函数不能用时，都要将变量声明在函数作用域范围内

   ​	d. 本质: 其实函数作用域也是一个保存所有局部变量的对象。只不过不是始终存在的。而是调用函数时临时创建，调用函数好，自动释放！

   ​	e. 优点: 仅函数内可访问，不会被污染

   ​	f. 缺点: 不可重用！

   #### 作用域链: 

   ​	(1). 什么是: 每个函数对象身上自带的，保存这个函数可以访问的所有作用域对象的集合。

### 9. 闭包: 

\3. 什么是闭包: 

​	(1). 用途: 专门反复使用一个变量，又保护变量不被污染的一种编程方式

​	(2). 什么是: 外层函数的作用域对象，被内层函数的作用域链引用着，无法释放，形成了闭包对象

\4. 何时: 今后只要希望给函数保护一个专属的可重用的变量时，都用闭包！

缺点：多占一块内存空间

```js
 function parent(){
      var total=1000;//变量！
      //2. 将外部想用的内层函数用return，返回到外层函数的外部。
      return function(money){
        total-=money;
        console.log(`花了${money},还剩${total}`);
      }
    }
    var pay=parent();
    pay(100); 
    total=0;//绝对改不了局部变量
    pay(100);
    pay(100);
```

### 10 什么是面向对象:

\1. 什么是: 先用对象结构描述出显示中每个事物的属性和方法，然后再按需调用对象中保存的属性和方法。

\2. 为什么: 为了便于大量数据的管理和使用！

\3. 何时: 今后几乎所有的程序都用面向对象思想开发出来的！

\4. 如何: 封装，继承，多态

 

### 11 封装: 创建对象

\1. 什么是: 将现实中一个事物的属性和功能，集中保存在一个对象结构中

\2. 为什么: 为了便于大量数据的管理和使用！

\3. 何时: 今后只要使用面向对象的方式编程，都需要先创建对象，保存现实中事物的属性和功能。

### 12 什么是构造函数: 专门描述同一类型的所有对象的统一结构的函数

今后只要需要反复创建多个相同结构，但是属性值不同的同一类型的多个对象时，都要用构造函数

\5. 如何: 2步

​	(1). 定义构造函数

​	(2). 用new调动构造函数

缺点: 如果构造函数中包含方法定义，则每创建一次新对象，就会创建方法的副本。浪费内存！

继承

### 13继承

 什么是继承: 父对象中的成员，子对象无需重复创建，就可直接使用！

 为什么: 既重用方法，又能节约内存！

何时: 只要希望一个方法，只定义一次就能让所有新对象共同使用时，都要通过继承来实现

如何: 

​		新子对象._ _proto_ _=构造函数.prototype

\9. 结果: 只要子对象的_ _proto_ _属性指向了父对象，今后，使用子对象可直接调用父对象中的成员！无需重复创建！就像调用自己的方法一样！毫无差别！

### 14自有属性和共有属性: 

什么是: 

​	a 自有属性: 直接保存在当前对象内部，归当前内部独有的属性

​	b. 共有属性: 保存在原型对象中，归所有子对象共有的属性

### 15内置类型的原型对象: 

​	(1). 什么是内置类型/内置对象: ECMAScript标准中规定的，浏览器已经实现的，我们可以直接使用的类型或对象。

​	(2). 包括: 11种: 

​	String Number Boolean

​	Array Date RegExp Math(对象)

​	Error

​	Function Object

​	global(对象)(在浏览器中被window对象代替)

 问题: 将来ES不断升级的过程中，每种类型新增了哪些好用的函数？

​		答: 就看这个类型的原型对象即可！

​	(5). 问题: 如果经常使用的一个功能，在原型对象中没有提供！怎么办？

​		答: 可以向该类型的构造函数中添加一个自定义的函数。

​		结果: 在这个项目中，所有这个类型 子对象都可以使用自定义的函数

### 16原型链:

由多级父对象逐级继承形成的链式结构

​	(4). 保存着一个对象可用的所有属性和方法。

### 17多态

 什么是多态: 一个函数在不同情况下表现出不同的状态！

\2. 包括2种: 重载 和 重写

\3. 问题: 不同类型的子对象，调用相同的toString()方法，输出结果的格式，千差万别！

​	(2). 大部分内置类型在调用toString时，几乎都是想输出对象的内容。

​	(3). 所以，各种内置类型的原型对象中，都根据自己类型的需要，重写了更好用的输出对象内容的toString()。



### 18 什么是重写

 如果觉得从父对象继承来的成员不好用，子对象可以在自己内部定义和父对象中同名的成员。将来子对象调用同名成员时，优先使用自己内部的成员。

为什么: 从父对象继承来的成员不总是好用的！

 何时: 今后，只要觉得从父对象继承来的成员不好用，都可以在子对象中重写同名的成员。